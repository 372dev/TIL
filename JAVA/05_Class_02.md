# Java_05_Class_02

## :muscle:생성자와 메소드

### :star:메소드 정의하는 방법
보통 다른언어에는 함수라는 것이 별도로 존재한다. 하지만 자바는 클래스를 떠나 존재하는 것은 있을 수 없기 때문에 자바의 함수는 따로 존재하지 않고 클래스 내에 존재한다. 자바는 이 클래스 내의 함수를 메소드라고 부른다.

메소드의 선언부에 메소드의 속성들을 작성해보자. 일반적으로 다음과 같은 형태를 갖게 된다.  

> 접근지정자 자료형 메소드명 (매개변수1, 매개변수2, ...) {  
>    // 실행할 코드  
>}  

#### :mag:메소드명 정하기
메소드명은 다음과 같이 camelCase를 사용하여 작성한다.

* 한 단어 메소드명: sum(), area()
* 여러 단어 메소드명: areaOfCircle(), stringComparision()

또한 같은 이름의 메소드를 여러개 만들수도 있는데 이를 메소드 오버로딩이라 한다.

#### :mag:메소드 오버로딩
한가지 작업을 수행해야 하는데 있어 메소드들의 이름이 동일하다면 읽기 좋고 깔끔한 코드라 할 수 있겠다.
예를들어 덧셈을 하는 기능을 구현하는데 있어 값이 다양한 개수가 될 수 있는데, 메소드 a(int, int), 메소드b(int, int, int)... 와 같이 이름이 다른 메소드를 여러개 있다면 메소드명의 차이 때문에 다른 작업자가 보기에 이해하기 어려울 수 있다.

메소드 오버로딩을 할 때에는 오버로딩되는 메소드간에 다음과 같은 규칙을 지켜줘야 한다.
1. 메소드들의 이름이 동일하다
2. 메소드간에 매개변수 개수가 다르거나, 매개변수 자료형이 다르다
3. 접근지정자, 반환자료형, 예외처리 등은 관계 없다

### :star:객체 만드는 방법 (new 키워드 이해하기)
생성자를 통해 객체가 만들어지는 과정을 살펴보자. Circle 이라는 객체를 만들기 위해 다음과 같은 구문을 사용할 수 있다.

>Circle c = new Circle();  

위 구문이 실행되면 Circle 클래스의 새로운 인스턴스를 생성하게 될것이며, 그 과정에서 생성자가 실행될 것이다.
사실 Circle() 키워드는 생성자를 지칭한다. 생성자는 클래스의 요소이며 클래스와 동일한 이름을 갖는다. 그리고 생성자는 메소드와 비슷한 형태를 갖는다.
생성자가 작동하는 과정에 대해서 알아보자. "new" 키워드가 해당 클래스의 새로운 인스턴스를 만들어야 할것을 주문했다. 먼저, 새로운 인스턴스를 담을 메모리가 할당된다. 뒤이어 생성자가 호출된다. 생성자에 코드가 작성되어있다면 함께 실행된다. 필요한 작업을 마친 생성자는 새로운 객체를 만들어 낸다.
자바의 모든 클래스는 적어도 하나의 생성자를 갖고 있다. 그 생성자들의 존재 이유는 새로운 객체의 생성을 위해서 이다. 프로그래머가 명시적으로 생성자를 작성하지 않았다면 자바 컴파일러가 기본생성자라고 불리는 생서자를 만들어 준다. 기본 생성자는 아무런 매개변수도 없고 어떤 특별한 작업도 하지 않는다.

### :star:생성자 정의하는 방법
생성자를 정의하는 데에는 몇가지 규칙이 있다.

1. 생성자 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 명시적인 리턴 타입을 가지면 안된다.
3. 자바 생성자는 abstract, static, final, synchronized 등의 키워드를 사용할 수 없다.

#### :mag:아무런 매개변수도 갖고있지 않은 생성자는 "기본생성자"라고 한다.
아무런 생성자도 작성하지 않은 클래스의 경우 컴파일러가 기본생성자를 만들어 준다. 그러나 기본생성자가 이미 있거나 매개변수를 가진 생성자가 있다면 컴파일러는 기본생성자를 만들지 않는다.

#### :mag:매개변수가 있는 생성자
생성자가 매개변수가 하나 이상 가진 경우에
갖고있는 데이터로 필드값을 지정한 채로 인스턴스를 만들고 싶은 경우 이용한다.

#### :mag:자바 생성자의 오버로딩
자바의 생성자는 마치 리턴타입이 없는 자바 메소드와 같다. 메소드와 마찬가지로 생성자도 오버로딩이 가능하다.
생성자 오버로딩을 이용하여 서로 다른 매개변수를 가진 생성자를 여러개 만들 수 있다. 여러개의 생성자를 가짐으로서 각각의 생성자가 서로 다른 역할을 수행하도록 할 수 있다. 
컴파일러는 각각의 오버로딩된 생성자를 매개변수의 개수나 타입의 차이를 통해 구분할 수 있다.

#### :mag:자바 생성자와 자바 메소드의 차이

| 자바 생성자                                                          | 자바 메소드                                                       |
|----------------------------------------------------------------------|-------------------------------------------------------------------|
| 해당 클래스의 인스턴스인 객체를 생성하기 위해서 생성자가 이용된다    | 객체의 능동적인 기능을 정의하기 위해서 이용된다                   |
| 생성자에는 리턴타입이 없다                                           | 메소드는 리턴 타입을 갖는다                                       |
| 생성자는 묵시적으로 이용된다                                         | 메소드는 명시적으로 이용된다                                      |
| 생성자를 작성하지 않을 경우, 자바 컴파일러가 기본생성자를 제공해준다 | 메소드는 어떤 경우에도 컴파일 단계에서 자동적으로 제공되지 않는다 |
| 생성자 이름은 클래스 이름과 같아야 한다                              | 메소드 이름은 클래스 이름과 같을수도 다를수도 있다                |

### :star:this 키워드 이해하기
this는 인스턴스 자기 자신을 가리키는 참조변수이다.

this.latitude = latitude; 와 같은 문장은
해당 인스턴스의 필드값인 this.latitude를 외부의 매개변수로 받은 latitude로 초기화시킨다. 라는 의미이다.

#### :mag:this()
this()는 해당 객체 내부의 생성자를 뜻한다. 아래의 코드 예시를 보자

```java
public class Animal {
    String name;
    Place place;

    public Animal() {
        this("animal",new Place(0,0,0));
    }

    public Animal(String name) {
        this(name,new Place(0,0,0));
    }

    public Animal(String name, Place place) { //<------생성자
        this.name = name;
        this.place = place;
    }

    public void move(int latitude, int longitude, int altitude) {
        place.changePlace(latitude,longitude,altitude);
    }
}
```

위에서 볼 수 있는 예시와 같이 this(...)를 사용하여 클래스 내부에 선언한 생성자 메소드를 불러올 수 있으며 이를 생성자 체이닝이라고 한다.

-References :
Java in a Nutshell by Benjamin J.Evans & David Flanagan  
https://leemoono.tistory.com/17  
https://www.javatpoint.com/java-constructor  
https://www.geeksforgeeks.org/constructors-in-java/  
https://www.javatpoint.com/method-in-java  
https://www.javatpoint.com/method-overloading-in-java  
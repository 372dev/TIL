# Java_06_Inheritance_02

## :muscle: 메서드 오버라이딩, 메서드 디스패치, final 키워드, Object 클래스

### :star:메서드 오버라이딩
어느 객체지향 프로그래밍 언어에서나 볼 수 있는 기능인 오버라이딩은 부모 클래스의 메서드를 자식 클래스에 가져와 특정 내용을 구현해서 사용한다.

자바에서도 자식 클래스가 부모 클래스에서 선언된 메서드와 같은 이름의 메서드를 선언하면 이를 자바의 메서드 오버라이딩이라 한다. 메서드 오버라이딩은 자바가 런타임 다형성을 갖는 방법중의 하나이다.
부모 클래스의 메서드, 그리고 자식 클래스의 오버라이딩된 메서드 둘중 어느 메서드를 사용할지는 어느 객체에서 메서드가 실행되는지에 의해 결정된다. 부모 클래스의 객체가 사용되었다면 부모 클래스의 메서드가 사용되고 자연히 자식 클래스의 객체에서 실행된다면 오버라이딩된 메서드가 실행된다.

* 메서드 오버라이딩의 규칙
  1. <b>오버라이딩과 접근지정자</b> : 하위 클래스의 메서드의 접근지정자는 오버라이딩된 상위 클래스의 메서드보다 같거나 더 넓은 범위를 지정해야 한다. 예를 들어, 상위 클래스로부터 protected로 지정된 메서드를 오버라이드 했다면, 오버라이딩된 하위 클래스의 메서드는 public으로 지정할수는 있겠지만 private으로 지정할 순 없다. 이를 어길시 컴파일 에러가 발생한다.
  2. <b>Final 메서드는 오버라이드 될 수 없다</b> : 오버라이드 되지 못하게 하고 싶은 메서드가 있다면 final 키워드를 이용할 수 있다. 상속과 final 키워드에 대해서는 아래에서 자세히 알아보자.
  3. <b>Static 메서드는 오버라이드 될 수 없다</b> : static 메서드는 변경될 수 없으므로 오버라이드 할 수 없다. 다만, 부모 클래스와 자식 클래스 모두 같은 이름과 형태의 정적 메서드를 가질수는 있으며 이를 메서드 하이딩이라고 한다. 딱히 메서드 하이딩을 활용할 일이 있을 것 같진 않다.
  4. <b>Private 메서드는 오버라이드 될 수 없다</b> : static 메서드와 비슷하게 private 메서드 또한 오버라이드가 불가능하며, 부모와 자식 클래스 각각 같은 이름의 private 메서드를 만들 수는 있다.
  5. <b>두 메서드의 리턴 타입이 같아야 한다</b> : 자바 5버전부터는 오버라이드된 메서드가 부모 클래스의 메서드와 다른 리턴 타입을 갖는게 가능하긴 하지만, 자식 클래스의 오버라이드된 메서드 리턴타입은 부모 클래스 메서드의 서브타입이어야 한다. 이 현상을 공변(covariant) 리턴 타입 이라고 불리운다.
  6. <b>오버라이드된 메서드 말고 부모클래스의 메서드를 호출하려면</b> : 자식 클래스에 오버라이딩된 메서드가 있더라도 super 키워드를 이용하여 자식 클래스에서 부모클래스의 메서드를 호출 할 수 있다.
  7. <b>생성자는 오버라이드 될 수 없다</b> : 생성자는 오버라이드가 불가능하다. 부모 클래스와 자식 클래스가 같은 생성자 이름을 가질 수 없기 때문이다. (생성자의 이름은 클래스 이름과 같아야 한다.)
  8. <b>오바리이딩과 예외처리</b> : 예외처리와 관련된 메서드를 오버라이드 할 때에는 아래 두가지 규칙이 적용된다.
    * 상위 클래스의 메서드가 예외를 던지지 않는다면, 하위 클래스의 오버라이드된 메서드는 언첵드 익셉션(unchecked exception)만 던질 수 있다. 첵드 익셉션(checked exception)을 던지면 컴파일 에러가 발생한다.
    * 상위 클래스의 메서드가 예외를 던진다면, 하위 클래스의 오버라이드된 메서드도 상위 클래스 메서드와 동일한 예외 혹은 하위 클래스 예외만 던질 수 있다. 상위 클래스 예외를 던질 경우 컴파일 에러가 발생한다. 오버라이딩된 하위 클래스의 메서드가 예외를 던지지 않더라도 문제될 건 없다. (헷갈릴 수 있는데, 접근지정자와 비교해서 생각하면 쉽다.)
  9. <b>오버라이딩과 추상 메서드</b> : 추상 클래스나 인터페이스의 추상 메서드의 경우 애초에 오버라이드 하기 위해 존재하므로 오버라이드 하지 않을 경우 컴파일 에러가 발생한다.
  10. <b>오버라이딩과 synchronized / strictfp 메서드</b> : 동기화(synchronized) 혹은 엄격한 부동소수점(strict floating point) 옵션이 적용된 메서드도 오버라이드 가능하다. 그러한 메서드에서 일반 메서드로 오버라이딩도 가능하고 그 반대로도 가능하다.

### :star:메서드 디스패치 (Method Dispatch)
메서드 디스패치란 어떤 메소드를 호출할지 결정하여 실제로 실행시키는 과정이다. 자바는 런타임 시 객체를 생성하고, 컴파일 시에는 생성할 객체 타입에 대한 정보만 보유한다.
디스패치 방식에는 스태틱(Static)과 다이내믹(Dynamic)이 있다. 스태틱 디스패치는 메서드의 호출이 컴파일 단계에서 이뤄지는 것이며 다이내믹 디스패치의 경우 런타임에서 이뤄지는 것이다. 다이내믹 디스패치는 다형성을 가능케 하는 매커니즘이다.

생각해 보면, 부모 클래스의 변수가 자식 클래스의 객체를 가리키고 있다고 했을 때, 자식 클래스에서 오버라이드 된 메서드를 호출한다면 그 호출은 자식 클래스로 보내지게 될것이다. 이런 현상은 객체지향 프로그램이 호출을 동적으로 가상의 메서드들로 보내기 때문이다. 그러지 않았다면, 하나의 메서드로부터 오버라이드되어 다양하게 구현된 기능을 제공할 수 없었을 것이다. 이는 객체지향 프로그래밍의 다형성(Polymorphism)과 관련이 있다.

#### :mag:다형성 (Polymorphism)
객체지향개념에서 다형성이란 여러가지 형태를 가질 수 있는 능력을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.
구체적으로 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 한 것이다. 다음과 같은 코드가 있다.

```java
class Parent {
    String strP;
    int intP;

    void methodP() { }
}

class Child extends Parent {
    String strC;

    void methodC() { }        
}
```

두 클래스는 상속관계에 있고, 두 클래스의 인스턴스를 생성하고 사용하려면 다음과 같이 해야한다.

```java
Parent p = new Parent();
Child c = new Child();
```

생성된 인스턴스를 다루기 위해서는 인스턴스의 타입과 일치하는 타입의 참조변수만을 사용했다. 이처럼 인스턴스의 타입과 참조변수의 타입이 일치하는 것이 보통이지만, 서로 상속관계에 있을 경우 다음과 같이 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조하도록 하는 것도 가능하다.

```java
Parent p = new Child();
```

이렇게 조상클래스의 참조변수가 자손클래스의 인스턴스를 참조하는것을 업캐스팅(Upcasting)이라고 한다.

#### :mag:업캐스팅 (Upcasting)
자바에서는 업캐스팅이 가능하며 이는 하나의 부모 클래스에서 여러개의 자식 클래스로 상속이 이뤄질 때 아주 유용하다. 그런 경우에 부모 클래스로 참조변수를 만들고 자식클래스 인스턴스를 참조한다.

```java
class 진돗개
{
 	public void type()
 	{  
 		System.out.println("용맹하다"); 
 	}
}

class 강아지 extends 진돗개
{
 	public void type()
 	{  
 		System.out.println("귀엽다"); 
	}

 	public static void main(String[] args)
 	{
   		진돗개 jindo1 = new 진돗개();
   		강아지 pup = new 강아지();

   		jindo1.type(); // "용맹하다"
   		pup.type(); // "귀엽다"

   		진돗개 jindo2 = new 강아지();

   		jindo2.type(); // "귀엽다"
 	}
}
```

#### :mag:다이내믹 디스패치 (Dynamic Dispatch)
대부분의 객체지향 프로그래밍 언어는 가상 메서드 테이블(Virtual Method Tables)을 통해서 다이내믹 디스패치를 지원한다. 자식클래스의 객체를 인스턴스화 할 때, 메모리를 할당하며 해당 객체에 더해 부모 객체의 메모리까지 할당한다. 그리고 그렇게 합쳐진 메모리에 대한 참조가 리턴된다. 일반적으로 이 리턴된 정보는 참조변수에 담아둔다.

* 스태틱 디스패치와 다이내믹 디스패치의 차이점
  * 스태틱 디스패치는 메서드의 호출이 컴파일 단계에서 이뤄지며 다이내믹 디스패치의 경우 런타임에서 이뤄진다.
  * 스태틱 디스패치는 타입정보(클래스)를 이용하여 바인딩을 하며 다이내믹 디스패치의 경우 인스턴스화된 객체를 통해 메서드를 호출한다.
  * 오버로드된 메서드들은 스태틱 디스패치로 바인딩 되고 오버라이드된 메서드들은 런타임에서 다이내믹 디스패치로 바인딩 된다.

간단하게 말해서, 스태틱 디스패치는 메서드를 호출하는 객체의 타입이 컴파일러에 의해 "컴파일시" 정해지는 것이고. 다이내믹 디스패치는 컴파일러에 의해 "런타임"에서 정해지는 것이다.

#### :mag:더블 디스패치 (Double Dispatch)
- 자바에서 더블 디스패치는 원래 허용되지 않지만 오버로딩을 이용해서 가능한 것 같다. 좀더 공부해보고 다시 알아보자.

### :star:final 키워드
자바에서 final 키워드는 변수, 메서드, 클래스에 쓰일 수 있다.

1. final 변수
변수를 final로 선언하면 그 값을 바꿀 수 없다(상수가 된다).

2. final 메서드
메서드를 final로 선언하면 오버라이드 할 수 없게 된다.

3. final 클래스
클래스를 final로 선언하면 상속을 할 수 없게 된다.

* blank final 변수 혹은 uninitialized final 변수는 뭘까?
final 변수를 선언하며 초기화 하지 않은 경우 blank final 변수라고 한다.
객체를 생성하는 시점에서 초기화 하고 그 초기화된 값이 변하지 않게 하고 싶다면 blank final 변수를 유용하게 사용할 수 있겠다.
꼭 생성자에서 초기화를 해줘야 한다.

#### :mag:final과 상속
* 상속을 방지하기 위한 final 키워드
클래스를 final로 선언하면 상속을 할 수 없는데, 다른 말로 하위 클래스를 만들 수 없게 된다. 변경하면 안되는 클래스를 만들 때 유용한데 가장 친숙한 예로 String 클래스가 있다.

* 오버라이딩을 방지하기 위한 final 키워드
메서드를 final로 선언하면 오버라이드 할 수 없게 되는데, 하위 클래스에서 그 메서드를 변경 없이 사용해야 한다. Object 클래스가 전형적인 예로, 다수의 final 메서드를 갖고 있다.
다만 final 메서드로의 선언을 무조건 최상위 클래스에서만 해야 하는건 아님을 기억하자. 어느 상속 시점에서든 final로 선언된 메서드가 있다면 그 다음 하위 클래스 부터 final 메서드로 상속된다.

### :star:Object 클래스
Object 클래스는 java.lang 패키지에 담겨있다. 자바의 모든 클래스는 오브젝트 클래스를 상속한 자식 혹은 자손 클래스이다. 상속을 하지 않은 클래스라면 Object 클래스의 자식 클래스이고, 다른 클래스를 상속하는 클래스라면 Object 클래스의 자손 클래스이다. 결국 Object 클래스가 자바의 최상위 클래스이고, 모든 상속 구조의 뿌리로 자리잡고 있으며 그에 따라 Object 클래스의 메서드들은 어느 자바 클래스에서나 사용이 가능하다.

* Object 클래스 메서드
  1. <b>toString()</b> : 객체의 내용을 문자열로 표현해준다. Object 클래스의 오버라이딩 되지 않은 기본 toString 메서드는 해당 인스턴스를 생성한 클래스의 이름, 골뱅이(@ : at-sign), 그리고 객체의 해쉬코드를 부호없는 16진수로 담은 문자열을 리턴한다.
  2. <b>hashCode()</b> : 모든 객체에 대하여, 자바가상머신(JVM)은 중복 없는 해쉬코드를 각각 배정해준다. hashCode 메서드는 그 고유의 숫자를 Integer로 리턴해준다. 흔히 잘못 알려진 바로 hashCode 메서드가 객체의 주소를 리턴하는 것이라고 알려져 있는데, 사실이 아니다. 정확히는 객체의 주소를 알고리즘을 통해 숫자로 변환한 것이다. hashCode 메서드는 native 메서드(C/C++에서 유래한 메서드)인데 자바만으로는 객체의 주소를 찾는 것이 불가능하기 때문이며, 객체의 주소를 찾기 위해서 C/C++를 이용한다.
    * hashCode()의 활용
      * 컬렉션(collection)에서 객체를 찾기 위해서 사용한다. 자바가상머신(JVM)은 이 메서드를 해쉬와 관련된 자료구조(HashSet, HashMap, Hashtable 등) 안에 객체를 저장할 때 사용한다. 해쉬코드를 이용해서 저장하여 얻는 가장 큰 이점은 검색의 용이성이다.
      * hashCode()를 오버라이드 해서 고유값이 필요한 클래스에서 사용할 수 있다. 예를 들어 Student 클래스는 hashCode 메서드를 이용하여 학생마다 고유의 번호를 지정할 수 있다.
      * 동일성(Identity) 검사를 할 수 있다. 객체의 내용만 비교하는 것이 아니라 완전히 동일한 객체인지 검사한다.
  3. <b>equals(Object obj)</b> : 해당 객체를 "this" 객체(메서드를 호출한 객체)와 비교한다. 객체의 동등성을 검사하기 위해 일반적으로 사용된다. 오버라이드 하여 객체 동등성 비교 조건을 정해주는 것이 추천된다.
    * 주의점 : equals()메서드를 오버라이드 하였다면 hashCode() 메서드 또한 오버라이드 하는것이 좋다.
  4. <b>getClass()</b> : "this" 객체(메서드를 호출한 객체)의 클래스 객체를 리턴하며 해당 객체의 런타임 클래스를 얻기 위해 사용된다. 클레스의 메타데이터를 얻기 위해 사용될 수도 있다. 리턴된 클래스 객체는 변형할 수 없다.
  5. <b>finalize()</b> : 객체가 메모리 청소(Garbage Collected) 되기 직전에 호출된다. GC(Garbage Collector)가 호출하며 호출하며 해당 객체에 대한 참조가 더이상 없는지 확인하는데 사용된다. 사용자는 finalize() 메서드를 오버라이드 하여 시스템 리소스를 충당할 수 있다. 예를 들어 서블릿 객체가 제거되기 전에, finalize() 메서드를 통해 세션의 액티비티를 삭제한다.
  6. <b>clone()</b> : "this" 객체(메서드를 호출한 객체)와 동일한 객체를 복사하여 리턴한다.
  7. 나머지 세가지 메서드 <b>wait(), notify() notifyAll()</b>는 동시성(Concurrency)과 관련이 있다.

-References :
Java in a Nutshell by Benjamin J.Evans & David Flanagan  
https://www.geeksforgeeks.org/overriding-in-java/  
https://www.javatpoint.com/final-keyword  
https://www.geeksforgeeks.org/using-final-with-inheritance-in-java/  
https://www.geeksforgeeks.org/object-class-in-java/  
https://yadon079.github.io/2020/java%20study%20halle/week-06  
https://medium.com/ingeniouslysimple/static-and-dynamic-dispatch-324d3dc890a3  
https://www.studytonight.com/java/dynamic-method-dispatch.php